#!/usr/bin/env python3
import os
import sys
import json
import hashlib

def bhash(fs, hasher, bsize = 65536):
    buf = fs.read(bsize)
    while len(buf) > 0:
        hasher.update(buf)
        buf = fs.read(bsize)
        yield hasher

def main():
    episodes_file = sys.argv[1]
    source_dir = '.'
    try:
        source_dir = sys.argv[2]
    except IndexError:
        pass
    destination_dir = '.'
    try:
        destination_dir = sys.argv[3]
    except IndexError:
        pass

    with open(episodes_file, 'r') as fs:
        episodes_json = fs.read()
    episodes = json.loads(episodes_json)

    for title, episode in episodes.items():
        mkv_file_name = title+'.mkv'
        destination_path = os.path.join(destination_dir, mkv_file_name)
        tracks_infos = [destination_path]
        skip_episode = False
        for ref, track in episode['tracks'].items():
            hasher = hashlib.md5()
            ending = os.path.basename(track['source_path']).split('.')[1]
            source_file_name = track['id']+'.'+ending
            source_path = os.path.join(source_dir, source_file_name)
            md5hash = None
            with open(source_path,'br') as fs:
                for hasher in bhash(fs, hasher):
                    md5hash = hasher.hexdigest()
            if md5hash != track['md5_checksum']:
                skip_episode = True
                break
            tracks_infos.append(str(track['video_framerate']))
            tracks_infos.append(source_path)
        if skip_episode:
            sys.stderr.write(
                    "Track {} of episode {} is not complete or corrupted.\n"\
                            .format(source_path, title))
            continue 
        print(' '.join(tracks_infos))

if '__main__' == __name__:
    main()

